package hr.fer.zemris.java.hw03.prob1;

import java.util.Objects;

/**
 * 
 * Class represents a lexer used for character grouping
 * It has two states, BASIC AND EXTENDED that dictate the
 * rules by which the lexer operates.
 * It generates tokens that represent different character groups
 * More on token types can be seen in the TokenType enum
 * 
 * @author Tomislav KurtoviÄ‡
 *
 */

public class Lexer {
	
	/**
	 * Array of characters in which the 
	 * given text is transformed to
	 * 
	 */
	private char[] data; 
	
	/**
	 * Object that is generated by
	 * the lexer and represents 
	 * a character group;
	 * 
	 */
	private Token token; 
	
	/**
	 * Current position at which the
	 * lexer is located in the data array
	 */
	private int currentIndex; 
	
	/**
	 * State in which the lexer can be.
	 * BASIC or EXTENDED
	 * 
	 */
	private LexerState state;
	
	
	/**
	 * Constructor that takes in the text that 
	 * the lexer uses to group characters and
	 * exctract tokens
	 * 
	 * @param text text used for token extracting
	 */
	public Lexer(String text) { 
		text = text.trim();
		data = text.toCharArray();
		currentIndex = 0;
		state = LexerState.BASIC;
	}

	/**
	 * Evaluates token from data array and returns it
	 * 
	 * @return evaluated token
	 */
	public Token nextToken() { 
		evaluateToken();
		return getToken();
	}
	
	/**
	 * 
	 * Returns the current token
	 * 
	 * @return current token
	 */
	public Token getToken() {
		return token;
	}
	
	/**
	 * 
	 * Used for evaluating tokens.
	 * Its main purpose is to check the
	 * lexer state and call the appropriate 
	 * method.
	 * 
	 */
	private void evaluateToken() {
		if(token != null && token.getType().equals(TokenType.EOF)) {
			throw new LexerException("You have already reached the end of the string");
		}
		
		if(data.length == 0 || currentIndex > data.length-1) {
			token = new Token(TokenType.EOF,null);
			return;
		}
		
		if(isBlank()) {
			while(isBlank()) {
				currentIndex++;
			}
		}
		
		if(state == LexerState.BASIC) {
			basicLexerStateOperations();
		} else {
			extendedLexerStateOperations();
		}
		
	}
	
	/**
	 * Evaluates tokens in BASIC lexer state.
	 * It searches and evaluates words, numbers or symbols
	 * and sets the current token to that 
	 * appropriate type
	 * 
	 */
	private void basicLexerStateOperations() {
		//For letters and escape characters - WORD token
		if(Character.isLetter(data[currentIndex]) || isEscape() ) {
			StringBuilder builder = new StringBuilder();
			while(currentIndex < data.length && (Character.isLetter(data[currentIndex]) || isEscape())) {
				if(isEscape()) {
					currentIndex++;
					isInvalidEscapeFound();
				}
				builder.append(data[currentIndex]);
				currentIndex++;
			}
			token = new Token(TokenType.WORD, builder.toString());
			return;
		}
		
		//For numbers - NUMBER token
		if(Character.isDigit(data[currentIndex])) {
			StringBuilder builder = new StringBuilder();
			while(currentIndex < data.length && Character.isDigit(data[currentIndex])) {
				builder.append(data[currentIndex]);
				currentIndex++;
			}
			
			try {
				token = new Token(TokenType.NUMBER,Long.parseLong(builder.toString()));
			}catch(NumberFormatException ex) {
				throw new LexerException("Format of number is invalid");
			}
			return;
		}
		
		//For symbols - SYMBOL token 
		//If nothing else hits 
		token = new Token(TokenType.SYMBOL,data[currentIndex++]);
	
	}
	

	/**
	 * Evaluates tokens in EXTENDED lexer state.
	 * It searches and evaluates every character into a word
	 * group unless the character is a # symbol.
	 * It sets the current token to the appropriate
	 * type
	 * 
	 */
	private void extendedLexerStateOperations() {
		StringBuilder builder = new StringBuilder();
		while(!isBlank()) {
			if(data[currentIndex] == '#') {
				if(builder.length() != 0) {
					break;
				} else {
				token = new Token(TokenType.SYMBOL,data[currentIndex++]);
				return;
				}
			}
			builder.append(data[currentIndex]);
			currentIndex++;
		}
		token = new Token(TokenType.WORD,builder.toString());
	}
	
	/**
	 * Sets the state 
	 * 
	 * @param state state to set
	 */
	public void setState(LexerState state) {
		Objects.requireNonNull(state);
		this.state = state;
	}
	
	
	
	private boolean isBlank() {
		Character currentChar = data[currentIndex];
		
		if(currentChar.equals('\r')  || currentChar.equals('\n') || currentChar.equals('\t') || currentChar.equals(' ') ) {
			return true;
		}
		return false;
	}

	/**
	 * Checks if the character after the escape symbol 
	 * is valid or not.
	 * If not a <code>LexerException</code> is thrown
	 * 
	 */
	private void isInvalidEscapeFound() {
		
		if(currentIndex == data.length) {
			throw new LexerException("End of string and invalid escape found!");
		}
		if(Character.isLetter(data[currentIndex])) {
			throw new LexerException("Cannot have letter after escape character");
		}
		
	}
	
	/**
	 * Checks for escape characters
	 * 
	 * @return <code>true if it is an escpae character, </code> false otherwise
	 */
	private boolean isEscape() {
		if(data[currentIndex] == '\\') {
			return true;
		}
		return false;
	}
	

}
